# GitHub Actions Best Practices

**ðŸš§ This document is a work in progress ðŸš§**

## Objective

We desire a consistent GitHub actions style in our code base. This document
proposes a common set of standards for writing GitHub actions and workflows
within Bets Platform. This list is by no means thorough. If you find a style
worth documenting, add a comment or suggestion for review.

This document is both a **style guide** and a **best practices guide**.

## Input Naming

- Input names should use snake_case (e.g. project_id).
- Names should be specific and if applicable, should contain a suffix indicating
  units or sizing as needed (e.g. storage_size_gb).
- For booleans, default to `false` and name appropriately for intended use case

```yaml
inputs:
  # The logging feature is disable by default and the user needs to enable it
  enable_logging:
    description: "Enable the use of logging"
    required: false
    default: false

  # The cache feature is enabled by default and the user needs to disable it
  disable_cache:
    description: "Disable the use of caching"
    required: false
    default: false
```

## Accessing Inputs

Don't access inputs directly in shell steps, as this introduces a shell injection vulnerability:

> [!CAUTION]
> Don't do this:
> ```yaml
>   steps:
>     - name: 'Check inputs'
>       shell: 'bash'
>       run: |-
>         if [[ -z "${{ inputs.org-members-path }}" &&
>           ...
> ```

Instead, set the inputs as environment variables and access the envvars:

> [!TIP]
> Do this instead:
> ```yaml
>   env:
>     ORG_MEMBERS_PATH: '${{ inputs.org-members-path }}'
>   ...
> 
>   steps:
>     - name: 'Check inputs'
>       shell: 'bash'
>       run: |-
>         if [[ -z "${ORG_MEMBERS_PATH}" &&
>           ...
> ```
# Go Best Practices

We desire a consistent Go style in our code base. Even though the [Google Go style guide](https://google.github.io/styleguide/go/) and already provide many fundamental style decisions and best practices, there is still wiggle room for minor style inconsistency. It's more about keeping a _consistent_ preference rather than right or wrong.

**The list here won't repeat what's already in the [Google Go style guide](https://google.github.io/styleguide/go/). Please reference that first.** This list is also by no means thorough. If you find a style worth documenting, please reach out to one of the [Go readability approvers](https://github.com/abcxyz/readability/blob/main/terraform/go.yaml) to add your practices to this page.

## Go Repo Structure

The folder structure should mostly follow: https://github.com/golang-standards/project-layout. In our projects, we often need a couple of more things. Here is an example:

```
.
â”œâ”€â”€ apis            // All public APIs
â”‚   â””â”€â”€ v1alpha1    // APIs should be versioned
â”œâ”€â”€ sdk             // Sometimes we need sdk/client libs for different languages
â”‚   â”œâ”€â”€ go          // DO NOT have a separate Go module
â”‚   â””â”€â”€ java
â”œâ”€â”€ cmd
â”‚   â”œâ”€â”€ my-cli
â”‚   â””â”€â”€ my-service
â”œâ”€â”€ docs
â”œâ”€â”€ pkg
â”œâ”€â”€ protos          // Often we define public APIs in protos and generate them to the apis folder
â”‚   â””â”€â”€ v1alpha1    // APIs should be versioned; generated Go code should go to apis/v1alpha1
â”œâ”€â”€ scripts
â”œâ”€â”€ terraform       // For terraform modules
â””â”€â”€ test            // For integration/e2e tests
```

> [!IMPORTANT]
>
> `./terraform` should only contain terraform modules related to the project. To check in terraform code that uses such modules to provision cloud resources (where you actually run `terraform apply`), checkout the https://github.com/abcxyz/infra repo.

## OSS Dependencies

We should use the following OSS dependencies for the corresponding tasks.

* https://github.com/sethvargo/go-envconfig for loading env config (prefer the wrapper https://github.com/abcxyz/pkg/tree/main/cfgloader)
* https://github.com/sethvargo/go-retry for generic retry logic
* https://github.com/lestrrat-go/jwx/v2 for all JWT operations (see usage example in https://github.com/abcxyz/jvs)

> [!TIP]
>
> See https://github.com/abcxyz/pkg for commonly used utils we own.

## Consistency

### Pointers

Prefer pointers for any structure types. Prefer concrete types for built-in structures unless you need to distinguish between an empty value and an unprovided value. Always use pointer receivers for functions.

### Comments

- Godoc supports links (to symbols), lists, examples, etc. Find examples in https://pkg.go.dev/github.com/fluhus/godoc-tricks
  - Tip: Run `godoc -http=:8080` and go to `localhost:8080` to see visualized godoc
- Use `//` instead of `/* */`. If you use VS code, `Cmd + /` should comment out blocks in this style by default.
- Wrap comments at 80-character length. VS code extension like [Rewrap](https://marketplace.visualstudio.com/items?itemName=stkb.rewrap) can help you achieve that easily.

### Flags

Flag variables should be prefixed with "flag" to differentiate from non-flag variables, e.g. `var flagDebugMode bool`.

### Order & Group Imports

* Standard imports first: Golang official imports, like "fmt"
* Custom imports, e.g. `example.com/foo`
* Aliased imports, e.g. `foov2 example.com/foo/v2`
* Blank imports, e.g. `_ example.com/foo`
* Dot imports, e.g. `. example.com/foo`

```go
package main
import (
  "fmt"

  go "github.com/golang"

  "example.com/foo"

  _ "example.com/foo/blank"
  _ "github.com/golang/blank"

  . "example.com/foo/dot"
  . "github.com/golang/dot"
)
```


### Generating Protobuf Code

We want to use the native Go tooling [`go generate`](https://go.dev/blog/generate) to do the job. In the Go package where you want to generate the code, add a package level comment similar to the following one:

```go
//go:generate protoc -I../../../../third_party/googleapis -I../../../../protos/v1alpha1 --go_out=. --go-grpc_out=. --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative audit_log_request.proto audit_log_agent.proto

// Package v1alpha1 contains versioned Lumberjack contracts, e.g. audit log
// entry type, config, etc.
package v1alpha1
```

See the context in: https://github.com/abcxyz/lumberjack/blob/main/clients/go/apis/v1alpha1/doc.go

You may need to tweak the paths in the `protoc` command.

### The `realMain` Pattern

Any binary that exposes a `main` function (CLIs, servers, etc) must follow the `realMain` pattern. The `realMain` pattern calls for a "thin" `main()` function that invokes `realMain`, with `realMain` accepting a context and returning an `error` type. The `main()` function should only do the most minimal setup required, such as establishing a context and logger:

```go
package main

func main() {
  // Ensure the process responds to INT and TERM calls. By using a context,
  // downstream operations will terminate gracefully.
  ctx, done := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
  defer done()

  logger := logging.NewFromEnv("MY_SERVICE_")
  ctx = logging.WithLogger(ctx, logger)

  if err := realMain(ctx); err != nil {
    done()
    fmt.Fprintln(os.Stderr, err.Error())
    os.Exit(1)
  }
}

func realMain(ctx context.Context) error {
  db, err := database.Open("...")
  if err != nil {
    return fmt.Errorf("failed to open database: %s", err)
  }
  defer db.Close()

  cache, err := redis.Open("...")
  if err != nil {
    return fmt.Errorf("failed to open redis: %s", err)
  }
  defer cache.Close()

  // ...
}
```

This is important for error handling, context cancellation (interrupts), and for ensuring that any `defer` statements properly run before termination.

Consider the following **bad example**, which just uses `main`:

```go
// BAD - DO NOT USE
func main() {
  db, err := database.Open("...")
  if err != nil {
    log.Fatalf("failed to open database: %s", err)
  }
  defer db.Close()

  cache, err := redis.Open("...")
  if err != nil {
    log.Fatalf("failed to open redis: %s", err)
  }
  defer cache.Close()

  // ...

  log.Fatal(http.ListenAndServe("..."))
}
```

The `defer` statements to close the database and redis connections **will never run**. The call to `log.Fatal` immediately terminates the process and exits.


### Logging

Always use structured logging with [github.com/abcxyz/pkg/logging](https://github.com/abcxyz/pkg/tree/main/logging), which uses an opinionated instance of the `log/slog` Go standard library (Unless you are in one of the Exceptional cases below).

Exceptions to using [github.com/abcxyz/pkg/logging](https://github.com/abcxyz/pkg/tree/main/logging):
* Using the [Apache Beam Go SDK](https://beam.apache.org/documentation/sdks/go) for a pipeline to be run on [Dataflow](https://cloud.google.com/dataflow?hl=en): Dataflow has custom logging configurations that cause logging messages written with loggers from [github.com/abcxyz/pkg/logging](https://github.com/abcxyz/pkg/tree/main/logging) to always show as severity `INFO` in the Dataflow log window. The the Beam Go SDK provides a [logging package](https://github.com/apache/beam/tree/master/sdks/go/pkg/beam/log) that should be used instead. When using the sdk logger, log messages will appear with the appropriate severity in the Dataflow log window.
See the following for additional context/info:
  * https://github.com/abcxyz/github-metrics-aggregator/pull/171
  * https://cloud.google.com/dataflow/docs/guides/logging

Logs should:

-   Prefer the `Context` versions over the non-context versions:

    ```go
    // BAD - AVOID
    logger.Info("this is a message")
    ```

    ```go
    // GOOD
    logger.InfoContext(ctx, "this is a message")
    ```

-   Use all lowercase strings without punctuation for log messages:

    ```go
    // BAD - AVOID
    logger.InfoContext(ctx, "This is a Message.")
    ```

    ```go
    // GOOD
    logger.InfoContext(ctx, "this is a message")
    ```

-   Use lowercase strings and underscores for log keys in key=value pairs:

    ```go
    // BAD - AVOID
    logger.InfoContext(ctx, "something happened", "Key", value, "FishFood", flakes)
    ```

    ```go
    // GOOD
    logger.InfoContext(ctx, "something happened", "key", value, "fish_food", flakes)
    ```

-   Use `With` for key=value pairs that should appear on all log messages:

    ```go
    // BAD - AVOID
    logger.InfoContext(ctx, "something happened", "Key", value)
    logger.InfoContext(ctx, "something else happened", "Key", value)
    logger.InfoContext(ctx, "a third thing happened", "Key", value)
    ```

    ```go
    // GOOD
    logger = logger.With("key", "value")
    logger.InfoContext(ctx, "something happened")
    logger.InfoContext(ctx, "something else happened")
    logger.InfoContext(ctx, "a third thing happened")
    ```

-   Use the "logger" key to namespace logs (note: this is convention):

    ```go
    // GOOD
    logger.InfoContext(ctx, "something happened", "logger", "doSomething")
    ```

> [!CAUTION]
>
> **NEVER use `log.Fatal`!** If you are using the default logging package, `log.Fatal` is the equivalent of `log.Printf && os.Exit`. Calling `os.Exit` _immediately_ terminates the process, skipping any `defer` or cleanup operations. This can lead to leaky file descriptors or unclosed remote connections that are difficult to debug.

## Binary Release

### Single Binary

**Bundle user facing functionalities into a single binary as the entrypoint for each project.** Benefits are:

For maintainers:
- Only need to maintain the build / containerization process for a single binary
- Significantly reduce the build time
- By leveraging [the existing CLI package](https://github.com/abcxyz/pkg/tree/main/cli), it's easy to bake in consistency. E.g. [consistent helper documentation](https://github.com/abcxyz/jvs/pull/248), shared flags, etc.
- Helper documentation is now in code and will be updated accordingly when the behavior changes. It helps to reduce the amount of additional documentation required outside of code.

For users:
- Only need to operate a single binary. No need to worry about version matching.
- Binary usage is baked into the binary helper documentation and easily discoverable.

Bonus:
- As the original entry points (main functions) now become sub-commands, it encourages better unit testing (vs. we usually don't test `main.go`). See examples in [jvs/pull/245](https://github.com/abcxyz/jvs/pull/245).

> [!IMPORTANT]
>
> A notable exception is Dataflow. If you're writing a Dataflow job, the single binary pattern will not work well.

### Release

We use [goreleaser](https://goreleaser.com/) for Go project releases. For detailed usage, please refer to its public documentation. Here are the special practices we have adopted:

- Decouple the docker image release and SCM (github) release. This allows us to reuse goreleaser to build and push docker images without really creating a SCM release. To achieve this, we would need two goreleaser config files in the repo root:
  - `goreleaser.docker.yaml` contains the docker release logic. Use flag `-f .goreleaser.docker.yaml` to let goreleaser use this config.
  - `gorelease.yaml` contains the SCM (github) release logic. This is the default config goreleaser will look at.
- Docker multi-arch build and upload manifest list. See sample [`.goreleaser.docker.yaml`](https://github.com/abcxyz/lumberjack/blob/main/.goreleaser.docker.yaml).
  - `goreleaser.docker.yaml` should allow overriding container registry and image tag for non-release image build/push.

## Servers

### Ports

Servers should always listen on a port string, not int. Ports can be service names (e.g. "https"), so the following is technically valid code:

```go
net.Listen("tcp", "localhost:https")
```

Furthermore, Go's standard library [returns ports as strings](https://pkg.go.dev/net/url#URL.Port). Accepting a port as a string avoids unnecessary type conversions.


### Web Frameworks

No third party server frameworks are approved for use. This includes, but is not limited to [Gin](https://github.com/gin-gonic/gin) (and gin-contrib), [Beego](https://github.com/beego/beego), [fasthttp](https://github.com/valyala/fasthttp), [Buffalo](https://github.com/gobuffalo/buffalo).

We use the Go standard library ([`net/http`](https://pkg.go.dev/net/http)), for HTTP servers and request handling.


### Graceful Stopping

All servers must be gracefully stopped on termination. Servers should terminate on `SIGINT` and `SIGTERM`. The easiest way to ensure signals are propagated is to use a signal context that is passed to subsequent calls:

```go
ctx, done := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer done()

openDatabase(ctx)
openRedis(ctx)
```

Our [serving package](https://github.com/abcxyz/pkg/tree/main/serving) provides methods for codifying this behavior:

```go
ctx, done := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer done()

server, err := serving.New(port)
if err != nil {
  // TODO: handle error
}

// This will block until the provided context is cancelled.
if err := server.StartHTTP(ctx, httpServer); err != nil {
 // TODO: handle error
}
```

Note, when responding to _requests_, use the inbound `http/Request.Context()` instead. This ensures that the operation is canceled if the _user_ terminates the request:

```go
func (s *Server) HandleFoo() http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
  })
}
```

Use **Middleware** to inject values (such as a logger) into the request context.


### Middleware

Middleware is a well-established concept in grpc (called "interceptors"), so this section focuses on _HTTP_ middleware. Simply put, HTTP middleware is an [`http.Handler`](https://pkg.go.dev/net/http#Handler) that accepts another `http.Handler` as input. For example, here is a middleware that injects a logger:

```go
func WithLogging(l *logging.Logger, next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx = logging.WithLogger(ctx, l)
    r = r.WithContext(ctx)
    next.ServeHTTP(w, r)
  })
}
```

Middleware can also be trailing:

```go
func WithLatencyRecorder() http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    now := time.Now()
    defer log.Printf("request took %s", time.Since(now))
    next.ServeHTTP(w, r)
  })
}
```

Use middleware by wrapping any handlers:

```go
mux := http.NewServeMux()
mux.Handle("/foo", handleFoo)

stack := http.Handler(mux)
stack = WithLogging(logger, stack)
stack = WithLatencyRecorder(stack)

// ...

srv.ListenAndServe(stack)
```

### Routers and Handlers

Do **not** use global http functions. This includes `http.ListenAndServe` or `http.HandleFunc`. Always create a dedicated `http.Server` and a dedicated `http.ServeMux`:

```go
mux := http.NewServeMux()
mux.Handle("/foo", handleFoo())
mux.HandleFunc("/bar", handleBar)

server := &http.Server{
  Addr: ":" + port,
  Handler: mux,

  // ...
}
```

All HTTP serve functions must be named `handleXX` or `HandleXX` and return an `http.Handler`:

```go
// good:
func handleFoo() http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // ...
  })
}

// bad: bad name
func foo() http.Handler

// bad: does not return http.Handler
func handleFoo(w http.ResponseWriter, r *http.Request)
```

For more complex scenarios, create a dedicated server or controller package and expose a `Routes` function:

```go
package controller

type Controller struct {
  // fields ...
}

func New(// ...) *Controller {
  return &Controller{
    // ...
  }
}

func (c *Controller) Routes() http.Handler {
  mux := http.NewServerMux()
  mux.Handle("/foo", c.HandleFoo())
  mux.Handle("/bar", c.HandleBar())
  return mux
}

func (c *Controller) HandleFoo() http.Handler
func (c *Controller) HandleBar() http.Handler

//
//
//

package main

func realMain(ctx context.Context) error {
  c := controller.New()

  server := &http.Server{
    Addr: ":" + port,
    Handler: c.Routes(),
  }
}
```

By architecting servers as defined above, you can test individual handlers:

```go
func TestServerHandleFoo(t *testing.T) {
  t.Parallel()

  c := controller.New()

  r := httptest.NewRequest("GET", "/", nil)
  w := httptest.NewRecorder()

  c.HandleFoo()(w, r)

  // check w
}
```

### Health Check

HTTP and gRPC server should always implement health check API.

- [gRPC health check API](https://pkg.go.dev/google.golang.org/grpc@v1.54.0/health/grpc_health_v1). See [example](https://github.com/abcxyz/jvs/blob/main/pkg/cli/api_server.go#L117-L120).
- HTTP - return 200 on route `/healthz`. See [example](https://github.com/abcxyz/jvs/blob/main/pkg/cli/public_key_server.go#L122).

## Config

We prefer configuration to be aligned to the least common denominator across deployment environments. Since our servers and CLIs do not specifically target deployment platforms or runtimes, the least common denominator is the environment, specifically environment variables. This generally means declaring structs with `env` tags and parsing them using [sethvargo/go-envconfig](https://github.com/sethvargo/go-envconfig):

```go
type MyConfig struct {
  DevMode bool   `env:"DEV_MODE, default=false"
  Port    string `env:"PORT, default=8080"
}
```

Since nearly every deployment target has the ability to set environment variables, this approach avoids dependencies on the filesystem or specific configuration formats.

As a general rule declare sane default values where possible. Our deliverables should work out of the box with as little configuration as possible. This is not always possible, so be pragmatic and supplement with documentation as needed.

Projects that require many environment variables could benefit from using a dotenv file (e.g. `.env`) for local developer productivity. This file is usually ignored from source control and defines an exported list of environment variables for the required configuration:

```text
DEV_MODE="true"
PORT="8081"
```

There are multiple ways to use this file. The easiest is to "source" the file into your shell:

```shell
set -o allexport && source .env && set +o allexport
```

This will only affect your current shell session. If you open a new tab or close the terminal, you will need to source again. There are also editor plugins for [IntelliJ](https://plugins.jetbrains.com/plugin/7861-envfile) and [Visual Studio Code](https://code.visualstudio.com/remote/advancedcontainers/environment-variables) which will read this file automatically.

## Command line tools (CLIs)

All packaged command line tools must use the [github.com/abcxyz/pkg/cli](https://github.com/abcxyz/pkg/tree/main/cli) package. Small scripts and short example code may use Go's standard library. No other CLI packages are permitted.

The CLI package is fairly opinionated, but we also adhere to the following conventions:

### Structure and naming

- Command structures must be named `XXCommand`.
- Command structures should be in the same package.
- Flag names must use dashes as separators (not underscores):

    ```go
    // BAD: uses underscore
    f.StringVar(&cli.StringVar{
      Name: "first_name",
    })
    ```

    ```go
    // GOOD
    f.StringVar(&cli.StringVar{
      Name: "first-name",
    })
    ```

### Descriptions

Descriptions should start with an [action verb](https://www.thesaurus.com/e/grammar/action-verbs/) and should not end in a period or any other punctuation:

```go
// BAD: not an action verb
func (c *MyCommand) Desc() string {
  return "Cannot eat cookies"
}
```

```go
// BAD: ends with punctuation
func (c *MyCommand) Desc() string {
  return "Eats some cookies. "
}
```

```go
// GOOD
func (c *MyCommand) Desc() string {
  return "Eats some cookies"
}
```

The CLI will automatically truncate space and punctuation characters at the end of a description.

### Boolean flags

By convention, boolean flags should be false by default:

```go
// BAD: default value is "true" and flag is positive
f.BoolVar(&cli.BoolVar{
  Name:    "enable-cookies",
  Default: true,
})
```

```go
// GOOD
f.BoolVar(&cli.BoolVar{
  Name:    "disable-cookies",
  Default: false,
})
```

Try naming your flags to match this convention, because it reduces the cognitive overhead for users.

### Sharing common flags

Some commands may share a common set of flags. For example, you may have a set of flags for specifying retry values that should be shared among some commands. To share flags, create a dedicated `flags` package and a structure in that package to house the flags:

```go
// pkg/command/flags/retry.go
package flags

type RetryFlags struct {
  flagRetryAttempts int
  flagRetryTimeout  time.Duration
}

func (r *RetryFlags) Register(set *cli.FlagSet) {
  f := set.NewSection("RETRY OPTIONS")

  f.IntVar(&cli.IntVar{
    // ...
  })

  f.DurationVar(&cli.DurationVar{
    // ...
  })

  // Encapsulate any validation inside the set:
  set.AfterFunc(func(existingErr error) error {
    var merr error
    if r.flagRetryAttempts <= 0 {
      merr = errors.Join(merr, fmt.Errorf("-retry-attempts must be positive"))
    }
    return merr
  })
}
```

See the [persistent flags example](https://github.com/abcxyz/pkg/blob/main/cli/command_doc_persistent_flags_test.go) in the CLI repo for a complete example.

### Flag sections

By convention, section names should be all capital letters:

```go
// BAD: uses lowercase letters
f.NewSection("My section")
```

```go
// GOOD
f.NewSection("MY SECTION")
```

### Flag examples

When providing an example value, ensure that the example value is **different** from the default value.

```go
// BAD: default and example are the same
f.DurationVar(&cli.DurationVar{
  Default: 5*time.Minute,
  Example: "5m",
})
```

```go
// GOOD
f.DurationVar(&cli.DurationVar{
  Default: 5*time.Minute,
  Example: "30s",
})
```

### Post-parsing validation and mutation

The CLI package exposes an `AfterParse` function, which can be useful for things like validation and setting deferred defaults.

```go
func (c *MyCommand) Flags() *cli.FlagSet {
  set := c.NewFlagSet()

  f := set.NewSection("SERVER OPTIONS")

  f.StringVar(&cli.StringVar{
    Name:    "server-address",
    Example: "https://my.corp.server:8145",
    Default: "http://localhost:8145",
    EnvVar:  "CLI_SERVER_ADDRESS",
    Target:  &c.flagAddress,
    Usage:   "Endpoint, including protocol and port, the server.",
  })

  // Deprecated - use -server-address instead.
  f.StringVar(&cli.StringVar{
    Name:    "address",
    Default: "http://localhost:8145",
    Target:  &c.flagOldAddress,
    Hidden:  true,
  })

  // Each AfterParse will be invoked after flags have been parsed.
  set.AfterParse(func(existingErr error) error {
    // Example of deferred defaulting. At this point, it is safe to set values
    // of flags to other values.
    if c.flagOldAddress != "" {
      c.Errf("WARNING: -address is deprecated, use -server-address instead")
    }
    if c.flagAddress == "" {
      c.flagAddress = c.flagOldAddress
    }

    return nil
  })

  return set
}
```

See the [AfterParse example](https://github.com/abcxyz/pkg/blob/main/cli/command_doc_after_parse_test.go) in the CLI repo for more details.


## Testing

### Naming

Name the test in the format of `Test[<Struct>_]<Function>[_<details>]`.

### Test Helper

* Test helper functions should be prefixed with test to differentiate from non-test functions, e.g. `testToken(testing.TB)`
* Pass `testing.TB` whenever possible instead of `*testing.T`

### Table-driven

[Table-driven tests](https://dave.cheney.net/2019/05/07/prefer-table-driven-tests) make it easier to write exhaustive test cases, especially for unit tests.

* Each test case should have a unique test name.
* Each test case should be an _inline struct_ with a name field (do not use a map).
* Test case names must be only lowercase letters and underscores (this makes targeted testing with -run easier).

```go
func TestPerson_GetName(t *testing.T) {
  t.Parallel()

  cases := []struct {
    name  string
    input string
  }{
    {
      name:  "with_an_apple",
      input: "...",
    },

    // github.com/abcxyz/pkg#5
    {
        name:  "with_a_banana",
        input: "...",
    },
  }

  for _, tc := range cases {
    t.Run(tc.name, func(t *testing.T) {
      t.Parallel()

      // ...test...
    })
  }
}
```

### Parallelizable

As much as possible tests should be capable of running in parallel with all other tests. This includes sub-tests and table driven tests. Tests are marked as parallelizable with `t.Parallel()`. If a test cannot be parallelized, that is likely a bad encapsulation. Dependencies on the environment should be abstracted into an interface to maximize parallelization.

```go
func TestPerson_GetName(t *testing.T) {
  t.Parallel()

  cases := []struct {
    name  string
  }{
    // ...
  }

  for _, tc := range cases {
    t.Run(tc.name, func(t *testing.T) {
      t.Parallel()Ã¥

      // ...test...
    })
  }
}
```

If a test cannot be parallelized, it must be documented inline as to why it
cannot be parallelized, and the conditions under which it could be parallelized
in the future.

```go
// This test cannot be parallelized because the pizza service is not threadsafe.
func TestSendPizza(t *testing.T) {
  // ...test...
}
```

### `go test` should just work

The default `go test ./...` command should run all test files. Integration and functional tests that have dependencies (i.e. credentials or configuration) should call `t.Skip()` with an informative message. On CI, tests with missing dependencies should fail.

> [!TIP]
>
> Use https://github.com/abcxyz/pkg/blob/main/testutil/integ.go to make skipping integration tests easier. Add `testutil.SkipIfNotIntegration(t)` at the beginning of your test.

### Clean Up

If a test creates a resource, it must also delete that resource. This includes environment variables, files, and external Cloud resources. The easiest way to ensure a resources are cleaned is to use `t.Cleanup()`:

```go
func TestFile_Read(t *testing.T) {
  t.Parallel()

  f, err := os.CreateTemp("", "")
  if err != nil {
    t.Fatal(err)
  }
  t.Cleanup(func() {
    if err := os.RemoveAll(f.Name()); err != nil {
      t.Fatal(err)
    }
  })
}
```

```go
func TestObject_Get(t *testing.T) {
  t.Parallel()

  obj, err := sdk.CreateObject(&sdk.CreateObjectRequest{
    name: "my-obj",
  })
  if err != nil {
    t.Fatal(err)
  }
  t.Cleanup(func() {
    if err := sdk.DeleteObject(&sdk.DeleteObjectRequest{
      name: obj.Name,
    }); err != nil {
      t.Fatal(err)
    }
  })
}
```

### Self-contained

Minimize dependencies on external systems where possible. Tests should create and destroy the resources they need for execution (see also: "#clean-up").

In some cases, it may be necessary to have a prerequisite setup for tests, depending on the boundary for the tool. For tests that depend on GCP, project creation and service enablement should likely be handled outside the band of individual tests. This should be codified as Infrastructure as Code (IaC) using Terraform. The Terraform should be run once to configure a CI environment, not once per CI run.

More expensive operations that should be isolated for each test run should configure using the [TestMain](https://pkg.go.dev/testing#hdr-Main) pattern:

```go
var testDatabase *database.Database

func TestMain(m *testing.M) {
  testDatabase = expensiveOperationThatConfiguresADatabase()

  defer func() {
    testDatabase.Destroy()
  }()

  os.Exit(m.Run())
}
```

### Avoid Interdependency

The output of one test cannot influence the output of another test. On CI, the go test command must, at minimum, be run with:

```bash
go test -shuffle=on -count=1 -race -timeout=10m ./...
```

* `-count=1` - to ensure no cached tests.
* `-race` - to enable the race detector.
* `-shuffle=on` - to enable randomized test ordering.
* `-timeout=XXm` - to prevent run-away tests.

> [!TIP]
>
> In CI workflows, use `abcxyz/pkg/.github/workflows/go-test.yml@main` to run Go tests. It does all that for you.

### Unit Test Real Connections

If you're developing a HTTP or gRPC service, it's better to unit test them with local but real connection. In the same spirit, if your code under test directly depends on a HTTP or gRPC service, it's better to implement a fake and connect to it with local but real connection instead of entirely stubbing it out. Such way to test is closer to reality and provides better coverage.

* **HTTP** - Use https://pkg.go.dev/net/http/httptest. If you need a fake, write a fake _server_ rather than client.
* **gRPC** - We have a [testutil](https://github.com/abcxyz/lumberjack/blob/main/clients/go/pkg/testutil/grpc.go) to start a gRPC server locally on a random port. If you need a fake, write a fake _server_ and remember to embed the generated `UnimplementedXxxServer`. See an example [here](https://github.com/abcxyz/lumberjack/blob/main/clients/go/pkg/cloudlogging/processor_test.go).

## Error Handling

### Always `fmt.Errorf`

Prefer using fmt.Errorf to create errors even if no formatting is required. This helps to reduce the cognitive load to remember other ways to create errors (e.g. `errors.New`).

```go
fmt.Errorf("err no format")
// Instead of errors.New("err no format")
```

### Wrap External Error

For any errors that returned from a different package, we should always wrap the error:

```go
if err := externalPkg.Do(); err != nil {
  return fmt.Errorf("external pkg do failed: %w", err)
}
```

## Lint

For abcxyz Go projects, we use [`pkg/.golangci.yml`](https://raw.githubusercontent.com/abcxyz/pkg/main/.golangci.yml) for lint configuration. To run the linter locally:

```sh
# Install golangci-lint if you haven't done so
# go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

golangci-lint run -c <(curl https://raw.githubusercontent.com/abcxyz/pkg/main/.golangci.yml)
```
# JSON Best Practices
## Naming

### camelCase over snake_case

Property names should be camelCase wherever possible. This aligns with existing `abcxyz` code as well as [Google's JSON style guide](https://google.github.io/styleguide/jsoncstyleguide.xml?showone=Property_Name_Format#Property_Name_Format).

Currently, some repositories use `snake_case` for go struct tags, but those are due to them interacting with GitHub APIs which use `snake_case`.

### Initialisms

TBD
# PR Best Practices

## PR Title

We recommend using [conventional commit](https://www.conventionalcommits.org/en/v1.0.0/#summary) message for PR titles. It will make reviewing change logs more visually friendly.

## PR Description

With a clear PR title, you might think you don't need any PR description. This could be true, especially for the immediate reviewers who have context about your PR. But we still recommend having PR descriptions for the following reasons:

- Even for reviewers with the right context, it might be good to remind them what your changes are about.
- Provide the context for non-immediate reviewers, such as readability reviewers or people reviewing your promo packet.
- A place to highlight the challenges/complexity you're facing or the impact of your PR. The summary will help yourself and others to easily reference what kind of contributions you have done.

## Small Coherent PRs

Be mindful about your PR size. The smaller and more coherent a PR is, the easier it is for people to review and get approval.

## Long PR Comments

If you find yourself stuck in a long PR comment thread, it probably means there is some alignment that should have happened _before_ the PR. Please take time to make that happen first. Sometimes it means you need to close your current PR and start anew. The sooner you can take action, the less time you would feel wasted. Often _insisting_ on closing a long PR thread will end up costing more time and a bitter taste in people's mouth.

## Readability

Readability review is opt-in based at the moment, and probably will stay that way in the foreseeable future. But we recommend always adding the proper readability review group for your PRs unless you have that already. See existing readability groups in https://github.com/abcxyz/readability.
# Terraform Best Practices

## Objective

We desire a consistent Terraform style in our code base. This document proposes
a common set of standards for writing Terraform within Bets Platform. This list
is by no means thorough. If you find a style worth documenting, add a comment or
suggestion for review.

This document is both a **style guide** and a **best practices guide**.

## Readability

Bets Platform uses readability groups in GitHub `CODEOWNERS` files to ensure the
appropriate standards and style are followed. Complete the following steps to
add the abcxyz/terraform-readability team as `CODEOWNERS` for \*.tf files in the
service's repository

- Add the [abcxyz/readability](https://github.com/orgs/abcxyz/teams/readability)
  team as a contributor to the service's repository with `WRITE` access
  - This is a parent group that contains all readability teams and ensures
    readability teams can review code as needed
- Add the following lines to the `.github/CODEOWNERS` file:

```
# terraform-readability owns all terraform files
*.tf    @abcxyz/terraform-readability
```

## Google Cloud Organization Structure

TODO: Document this entire section and the use of the
[infra](https://github.com/abcxyz/infra) repository after getting automation and
new structure setup that follows go/bets-platform-org-setup.

For now, this is generalized.

Terraform in the [infra](https://github.com/abcxyz/infra) repository should
source a module in the service repository's `/terraform` folder to create the
resources required for the service(see
[Service Directory Structure](https://github.com/abcxyz/readability/wiki/_new#service-directory-structure)).
This allows a service's resources to be created in a consistent and repeatable
fashion per environment.

### Directory Naming

Directories should be named the same as the service's GitHub repository. If a
directory is needed that does not represent a service in a GitHub repository, it
should be named to reflect the context of what will be created. For example,
a` /resources/production` folder structure holds resources for the production
folder.

## Service Directory Structure

All Terraform should exist in a folder named `terraform` and should represent
the required resources for the services environment. In general, modules should
not need to be created for the service's environment. Prefer the use of our
[abcxyz/terraform-modules](https://github.com/abcxyz/terraform-modules)
repository for reusable infrastructure. If a new, reusable set of resources is
needed and represent a common set of functionality for use across Bets Platform,
it should go in the
[abcxyz/terraform-modules](https://github.com/abcxyz/terraform-modules)
repository. Otherwise, create the resources directly in the service's Terraform
configuration.

This provides the opinionated way to set up the infrastructure needed for the
service and allows consumers to re-use, or view it as an example of how to set
up their infrastructure.

### Example

```text
/terraform
  main.tf
  outputs.tf
  variables.tf
  terraform.tf
```

## File Structure and Naming

The following should be used to create and name the Terraform configuration
files:

- `main.tf` - The main file to create resources, locals, data sources, and call
  modules.

_NOTE: For larger projects, additional files can be used with an appropriate
name to supplement the main file, that groups related resources together (e.g. -
vms.tf, network.tf, etc)._

If required, make use of the following files:

- `outputs.tf` - Declare all outputs in this file.
- `variables.tf` - Declare all inputs in this file.

If required for Terraform configuration requirements:

- `terraform.tf` - Declare version requirements for Terraform and/or providers
  and any backend or provider configuration.

## Other Naming

### Resources

- Resource names should use snake_case (e.g. load_balancer) to match the
  Terraform resource naming format.

```terraform
resource "google_project" "test_service_project" {
  project_id = "test-service-${random_id.default.hex}"
  name       = "test-service"
}
```

### Variables/Outputs

- Variable names should use snake_case (e.g. project_id).
- Names should be specific and if applicable, should contain a suffix indicating
  units or sizing as needed (e.g. storage_size_gb).
- For booleans, default to `false` and name appropriately for intended use case

```terraform
variable "ram_size_gb" {
  type        = string
  description = "The service RAM size, in gigabytes."
}

# The logging feature would default to off and the user needs to enable it
variable "enable_logging" {
  type        = string
  description = "Enable the use of logging."
  default     = false
}

# The cache feature would be enabled by default and the user needs to disable it
variable "disable_cache" {
  type        = string
  description = "Disable the use of caching."
  default     = false
}

output "service_account_email" {
  description = "Service account email address."
  value       = google_service_account.service_account.email
}
```

### Google Cloud

- When naming Google Cloud resource, prefer using hyphens (-) as a separator
- Always review any Google Cloud naming constraints for the resource. Some have
  length limits and allowed character sets.
- For resources that must have a unique name, use the `random_id` resource to
  ensure uniqueness across Terraform runs.
- Prefer putting "project", "folder" and "organization" keys first in resource
  stanzas.

```terraform
resource "random_id" "default" {
  byte_length = 2
}

resource "google_project" "test_service_project" {
  project_id = "test-service-${random_id.default.hex}"
  name       = "test-service"
}
```

### Attribute Ordering

- Leading meta-arguments
  - The following argument should appear first and in the following order
  - `for_each`
  - `count`
  - `provider`
  - An empty newline should follow all meta-arguments for readability
- Module source
  - `source`
  - If there are no meta-arguments, an empty newline should follow all the
    module source attribute
- Provider specific preference
  - In general prefer top-level identifiers first
  - Google Provider (in this order)
    - `organization`
    - `folder`
    - `project`
- Ending meta-arguments
  - The following argument should appear last and in the following order
  - `depends_on`
  - `lifecycle`

```terraform
# with meta-arguments
module "some_modules" {
  for_each               = toset(["name_1", "name_2"])

  source                 = "git::https://github.com/owner/repo.git//modules/name?ref=SHA/TAG"

  project_id             = "project-id"
  name                   = each.value

  depends_on = [
    google_project_services.services["cloudbuild.googleapis.com"]
  ]

  lifecycle = {
    prevent_destroy = true
  }
}


# without meta-arguments
module "some_modules" {
  source                 = "git::https://github.com/owner/repo.git//modules/name?ref=SHA/TAG"

  project_id             = "project-id"
  name                   = each.value

  depends_on = [
    google_project_services.services["cloudbuild.googleapis.com"]
  ]

  lifecycle = {
    prevent_destroy = true
  }
}
```

## Formatting

All Terraform files should be formatted with the default Terraform formatter
using the `terraform fmt` command. The Bets Platform
[terraform-lint.yml](https://github.com/abcxyz/pkg/blob/main/.github/workflows/terraform-lint.yml)
linter should be set up in the service's repository to ensure proper formatting.

Visual Studio Code can be configured to auto format on save using the
[HashiCorp Terraform extension](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform)
and updating the user settings with the following values (per the docs):

**_NOTE: Visual Studio Code may need to be restarted for this to take effect_**

```json
  "[terraform]": {
    "editor.defaultFormatter": "hashicorp.terraform",
    "editor.formatOnSave": true,
    "editor.formatOnSaveMode": "file"
  },
  "[terraform-vars]": {
    "editor.defaultFormatter": "hashicorp.terraform",
    "editor.formatOnSave": true,
    "editor.formatOnSaveMode": "file"
  },
```

## Modules

### Creating Modules

Common modules should be located in the
[abcxyz/terraform-modules](https://github.com/abcxyz/terraform-modules)
repository. Modules in this repository should have a specific and reusable
function rather than trying to create a large module that tries to handle every
complex configuration possible.

#### Structure

```text
/<module_name>
  README.md
  main.tf
  variables.tf
  outputs.tf
  terraform.tf
```

### Sourcing Modules

Prefer using
[Generic Git](https://developer.hashicorp.com/terraform/language/modules/sources#generic-git-repository)
over HTTPS when sourcing modules. This option is generally easier to read and
provides the ability to inject GitHub PAT tokens to access private repositories
if needed.

Additionally, modules should always pin the version using a git tag or sha as
opposed to using the main branch. This locks the module in place and prevents
accidentally pulling the latest code that may break the infrastructure in
unexpected ways.

### Example

```terraform
module "github_ci_infra" {
  source                 = "git::https://github.com/abcxyz/terraform-modules.git//modules/github_ci_infra?ref=SHA/TAG"

  project_id             = google_project.github_metrics_ci.project_id
  name                   = "github-metrics"
  github_repository_name = "github-metrics-aggregator"
}
```

### Injecting PAT Token (GitHub Actions)

```shell
# using default github actions token
git config --global url."https://x-access-token:${{ github.token }}@github.com".insteadOf "https://github.com"

# using custom PAT token
git config --global url."https://<USERNAME>:${{ secrets.PAT_TOKEN }}@github.com".insteadOf "https://github.com"
```

## Google Provider

### General

- Prefer accepting a `project_id` as a variable instead of trying to inherit it
  from the provider.
  - Adding the `project_id` at the global provider level can have unwanted
    effects if you miss adding a `project_id` on a resource and it gets created
    in the wrong place. This can also be hard to catch when combing through plan
    output.

```terraform
# GOOD
variable "project_id" {
  description = "The GCP project ID."
  type        = string
}

resource "google_project_iam_member" "browser" {
  project = var.project_id
  role    = "roles/browser"
  member  = "group:some-group@google.com"
}
```

```terraform
# BAD
provider "google" {
  project = "my-project-id"
}
```

### google-beta

- The `google-beta` provider should only be used on a limited basis and only
  when a required beta feature is needed. If you aren't using a beta feature, do
  not include it in the `required_providers` configuration and do not include it
  in your resources
- When required, the provider attribute must be specified in the resource
  designated `google-beta` and should be the top most attribute

```terraform
resource "google_artifact_registry_repository" "image_registry" {
  provider = google-beta

  project       = var.project_id
  location      = "US"
  repository_id = "docker-images"
  description   = "Container Registry for the abcxyz images."
  format        = "DOCKER"
  depends_on = [
    google_project_service.services["artifactregistry.googleapis.com"],
  ]
}
```

### IAM

- In general, we prefer the use of `_member` resources for configuring IAM
  instead of `_binding` or `_policy`.
- `_member `resources are non-authoritative, meaning they add a member to a
  given IAM role and manage only that relationship. If other members are added
  to this role outside of Terraform, it will not cause Terraform to detect
  changes and try to reconcile them.
- `_binding` and `_policy` are authoritative, meaning they define the list of
  members for a given IAM role, any changes outside that list are considered
  "drift" and will be removed by Terraform on the next plan/apply cycle, i.e.
  Terraform becomes the source of truth.
- Using authoritative resources can trigger a lot of "drift" scenarios and have
  unwanted side-effects like removing Google Cloud default members for certain
  roles. Rather than relying on Terraform to enforce the IAM policy, we follow
  the principle of least-privilege to prevent changes to any IAM policies
  outside of Terraform.
# Quote all YAML strings!

```yaml
# Good
abc: 'xyz'
key1: '${{ env.VAL1 }}'

# Bad
foo: bar
key2: ${{ env.VAL2 }}
```

# License Header

YAML files should also license header as we consider them as code.
